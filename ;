"use client";
import React, { useEffect, useRef, useCallback } from "react";
import grapesjs, { Editor } from "grapesjs";
import "grapesjs/dist/css/grapes.min.css";
import { ref, onValue, set, off } from "firebase/database";
import { realDb } from "@/configs/firebase/firebase";
import { CodeMatcher, PrepareHTML_CSS_Structure } from "@/utilities/matcher";
import { LoadingSpinnerTransparent } from "../clientComponents/LoadingSpinner";
import { useUserStore } from "@/store/userStore";
import { SavePortFolioData } from "../result/actions";
import { useCodeLoader } from "./actions/codeLoader";

interface EditorProps {
  roomID: string;
  projectRef: string;
  ownerID: string;
}

export default function LiveEditor({
  roomID,
  projectRef,
  ownerID,
}: EditorProps) {
  useEffect(() => {
    const handleKeyDown = (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "s") {
        e.preventDefault();
        const html = editorRef.current?.getHtml();
        const css = editorRef.current?.getCss();
        alert("Saving to portfolio...");
        if (html && css) {
          saveToPortfolio(html, css);
        }
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [metaData, ownerID]);

  const editorRef = useRef<Editor | null>(null);
  const editorContainer = useRef<HTMLDivElement>(null);
  const isApplyingRemoteChange = useRef(false);
  const lastLocalChange = useRef<number>(0);
  const userId = useRef<string>(Math.random().toString(36).substring(7));

  // Enhanced change tracking
  const firebaseOperationInProgress = useRef(false);
  const lastSyncedContent = useRef<{ html: string; css: string }>({
    html: "",
    css: "",
  });
  const syncQueue = useRef<Array<{ html: string; css: string }>>([]);

  const path = React.useMemo(() => projectRef.split("/"), [projectRef]);
  console.log("Project path:", path);
  const { fetchedCode, metaData } = useCodeLoader(path);
  const { user } = useUserStore();

  // Track different types of editing with longer protection for styles
  const userIsEditingContent = useRef(false);
  const userIsEditingStyles = useRef(false);
  const contentEditingTimeout = useRef<NodeJS.Timeout | null>(null);
  const styleEditingTimeout = useRef<NodeJS.Timeout | null>(null);

  // Mark user as actively editing content
  const markUserEditingContent = useCallback(() => {
    userIsEditingContent.current = true;
    if (contentEditingTimeout.current)
      clearTimeout(contentEditingTimeout.current);
    contentEditingTimeout.current = setTimeout(() => {
      userIsEditingContent.current = false;
    }, 100);
  }, []);

  // Mark user as actively editing styles with longer protection
  const markUserEditingStyles = useCallback(() => {
    userIsEditingStyles.current = true;
    if (styleEditingTimeout.current) clearTimeout(styleEditingTimeout.current);
    styleEditingTimeout.current = setTimeout(() => {
      userIsEditingStyles.current = false;
    }, 800); // Much longer protection for styles
  }, []);

  // Combined editing check
  const isUserEditing = useCallback(() => {
    return userIsEditingContent.current || userIsEditingStyles.current;
  }, []);

  // Reliable Firebase sync with queue system
  const syncToFirebase = useCallback(
    async (html: string, css: string, force: boolean = false) => {
      if (
        !force &&
        html === lastSyncedContent.current.html &&
        css === lastSyncedContent.current.css
      ) {
        return;
      }

      // Add to queue if operation in progress
      if (firebaseOperationInProgress.current) {
        syncQueue.current.push({ html, css });
        return;
      }

      if (isApplyingRemoteChange.current && !force) return;
      if (userIsEditingStyles.current && !force) return;

      lastLocalChange.current = Date.now();
      firebaseOperationInProgress.current = true;

      const projectFirebaseRef = ref(realDb, `rooms/${roomID}/data`);

      try {
        await set(projectFirebaseRef, {
          html,
          css,
          updatedAt: Date.now(),
          userId: userId.current,
        });

        lastSyncedContent.current = { html, css };

        // Process queue
        if (syncQueue.current.length > 0) {
          const next = syncQueue.current.pop(); // Get latest change
          syncQueue.current = []; // Clear queue
          if (next) {
            setTimeout(() => syncToFirebase(next.html, next.css, false), 10);
          }
        }
      } catch (error) {
        console.error("Firebase sync failed:", error);
        // Retry after short delay
        setTimeout(() => syncToFirebase(html, css, force), 500);
      } finally {
        firebaseOperationInProgress.current = false;
      }
    },
    [roomID],
  );

  // Enhanced change handler that catches everything
  const handleEditorChange = useCallback(
    (isStyleChange = false) => {
      if (isApplyingRemoteChange.current || !editorRef.current) return;

      if (isStyleChange) {
        markUserEditingStyles();
      } else {
        markUserEditingContent();
      }

      const editor = editorRef.current;
      const html = editor.getHtml();
      const css = editor.getCss() || "";

      // Always sync to Firebase
      syncToFirebase(html, css);
      // Debounced portfolio save
    },
    [syncToFirebase, markUserEditingContent, markUserEditingStyles],
  );

  // Immediate change handler for critical events
  const handleImmediateChange = useCallback(
    (isStyleChange = false) => {
      if (isApplyingRemoteChange.current || !editorRef.current) return;

      if (isStyleChange) {
        markUserEditingStyles();
      } else {
        markUserEditingContent();
      }

      // Use setTimeout to ensure DOM is updated
      setTimeout(() => {
        if (!editorRef.current || isApplyingRemoteChange.current) return;

        const editor = editorRef.current;
        const html = editor.getHtml();
        const css = editor.getCss() || "";

        syncToFirebase(html, css, true); // Force sync
      }, 0);
    },
    [syncToFirebase, markUserEditingContent, markUserEditingStyles],
  );
  const saveToPortfolio = async (html: string, css: string) => {
    if (!ownerID || !metaData) {
      console.log(metaData);
      console.log("User or metadata not available for saving to portfolio.");
      return;
    }

    try {
      const newCode = PrepareHTML_CSS_Structure(html, css);
      await SavePortFolioData(
        newCode,
        ownerID,
        metaData.fileName!,
        metaData.ref!,
      );
    } catch (error) {
      console.error("Portfolio save failed:", error);
    }
  };

  useEffect(() => {
    if (!editorContainer.current || editorRef.current || !fetchedCode) return;

    const editor = grapesjs.init({
      container: editorContainer.current,
      height: "100vh",
      storageManager: false,
      undoManager: {
        trackSelection: false,
        maximumStackLength: 30,
      },
    });

    const { extractedHTML, extractedCSS, cssWithoutVariables } =
      CodeMatcher(fetchedCode);

    editor.setComponents(
      `${extractedHTML}<div data-gjs-type="script-placeholder"></div>`,
    );
    editor.setStyle(`${extractedCSS}\n${cssWithoutVariables}`);

    // Initialize lastSyncedContent
    lastSyncedContent.current = {
      html: editor.getHtml(),
      css: editor.getCss() || "",
    };

    editorRef.current = editor;

    // Firebase listener for remote updates
    const projectFirebaseRef = ref(realDb, `rooms/${roomID}/data`);

    const handleRemoteUpdate = (snapshot: any) => {
      const data = snapshot.val();
      if (!data || !editor) return;

      // Skip our own changes
      if (data.userId === userId.current) return;

      // Respect user editing with different timeouts for styles vs content
      if (isUserEditing()) {
        // For styles, wait longer before retrying
        const retryDelay = userIsEditingStyles.current ? 200 : 50;
        setTimeout(() => {
          if (!isUserEditing()) {
            handleRemoteUpdate(snapshot);
          }
        }, retryDelay);
        return;
      }

      const currentHtml = editor.getHtml();
      const currentCss = editor.getCss() || "";

      // Only apply if content is different
      if (data.html === currentHtml && data.css === currentCss) return;

      // Quick conflict check
      const timeDiff = Date.now() - lastLocalChange.current;
      if (timeDiff < 100) return;

      isApplyingRemoteChange.current = true;

      try {
        if (data.html !== currentHtml) {
          editor.setComponents(data.html);
        }
        if (data.css !== currentCss) {
          editor.setStyle(data.css);
        }

        lastSyncedContent.current = {
          html: data.html || "",
          css: data.css || "",
        };
      } catch (error) {
        console.error("Error applying remote changes:", error);
      }

      setTimeout(() => {
        isApplyingRemoteChange.current = false;
      }, 50);
    };

    onValue(projectFirebaseRef, handleRemoteUpdate);

    // Comprehensive event listening with style-specific handling
    const contentEvents = [
      "component:add",
      "component:remove",
      "component:update",
      "component:move",
      "component:clone",
      "component:drag:end",
      "change:content",
      "undo",
      "redo",
      "canvas:spot",
    ];

    const styleEvents = [
      "style:update",
      "style:property:update",
      "style:property:remove",
      "style:sector:update",
    ];

    // Handle style events with special protection
    styleEvents.forEach((event) => {
      editor.on(event, () => handleImmediateChange(true)); // Mark as style change
    });

    // Handle content events normally
    contentEvents.forEach((event) => {
      editor.on(event, () => handleImmediateChange(false)); // Mark as content change
    });

    // Enhanced RTE handling
    let rteObserver: MutationObserver | null = null;

    editor.on("rte:enable", () => {
      markUserEditingContent();
      setTimeout(() => {
        const rteElement = editor.Canvas.getDocument().querySelector(
          '[contenteditable="true"]',
        );
        if (rteElement && !rteObserver) {
          rteObserver = new MutationObserver(() => {
            handleImmediateChange(false); // Content change
          });
          rteObserver.observe(rteElement, {
            childList: true,
            subtree: true,
            characterData: true,
          });
        }
      }, 10);
    });

    editor.on("rte:disable", () => {
      if (rteObserver) {
        rteObserver.disconnect();
        rteObserver = null;
      }
      handleImmediateChange(false);
    });

    // Multi-layered change detection
    let canvasObserver: MutationObserver | null = null;
    let styleObserver: MutationObserver | null = null;

    setTimeout(() => {
      const canvasDoc = editor.Canvas.getDocument();
      const canvasBody = canvasDoc.body;
      const canvasHead = canvasDoc.head;

      // Body observer for content changes
      if (canvasBody) {
        canvasObserver = new MutationObserver((mutations) => {
          if (!isApplyingRemoteChange.current) {
            // Check if mutation affects styles
            const isStyleMutation = mutations.some(
              (mutation) =>
                mutation.type === "attributes" &&
                (mutation.attributeName === "style" ||
                  mutation.attributeName === "class"),
            );
            handleEditorChange(isStyleMutation);
          }
        });

        canvasObserver.observe(canvasBody, {
          childList: true,
          subtree: true,
          characterData: true,
          attributes: true,
          attributeFilter: ["style", "class", "id"],
        });
      }

      // Head observer for CSS style changes
      if (canvasHead) {
        styleObserver = new MutationObserver(() => {
          if (!isApplyingRemoteChange.current) {
            handleImmediateChange(true); // Always style change
          }
        });

        styleObserver.observe(canvasHead, {
          childList: true,
          subtree: true,
          characterData: true,
        });
      }
    }, 100);

    // Multiple polling frequencies for different scenarios
    const fastPoll = setInterval(() => {
      if (
        !isApplyingRemoteChange.current &&
        !firebaseOperationInProgress.current
      ) {
        handleEditorChange();
      }
    }, 150); // Fast polling

    const slowPoll = setInterval(() => {
      if (!isApplyingRemoteChange.current && !isUserEditing()) {
        handleEditorChange();
      }
    }, 500); // Backup polling

    // Cleanup
    return () => {
      clearInterval(fastPoll);
      clearInterval(slowPoll);
      if (contentEditingTimeout.current)
        clearTimeout(contentEditingTimeout.current);
      if (styleEditingTimeout.current)
        clearTimeout(styleEditingTimeout.current);

      if (rteObserver) rteObserver.disconnect();
      if (canvasObserver) canvasObserver.disconnect();
      if (styleObserver) styleObserver.disconnect();

      off(projectFirebaseRef, "value", handleRemoteUpdate);
      editor?.destroy();
      editorRef.current = null;
    };
  }, [
    fetchedCode,
    roomID,
    handleEditorChange,
    handleImmediateChange,
    markUserEditingContent,
    markUserEditingStyles,
    isUserEditing,
  ]);

  if (!fetchedCode) {
    return <LoadingSpinnerTransparent />;
  }

  return <div ref={editorContainer} className="h-full" />;
}
